// filepath: /backend/src/tests/unit/db.unit.test.ts
/**
 * Database Helper Unit Tests
 *
 * This test suite verifies the behavior of database utility functions,
 * including connection pooling, query execution, and client acquisition.
 * It ensures correct handling across environments (test, development),
 * proper logging behavior, and robust error handling.
 */

jest.mock('pg', () => {
    const actualPg = jest.requireActual('pg');
    return {
        ...actualPg,
        Pool: jest.fn().mockImplementation(({ connectionString }) => ({
            query: jest.fn(),
            connect: jest.fn(),
            options: { connectionString },
        })),
    };
});

jest.mock('../../config', () => ({
    config: {
        databaseUrl: 'postgres://test:test@localhost:5432/test',
        nodeEnv: 'test',
    },
}));

import { query, getClient, pool } from '../../models/db';
import { config } from '../../config';
import { PoolClient, QueryResult } from 'pg';

describe('Database Helper Unit Tests', () => {
    afterEach(() => {
        jest.clearAllMocks();
    });

    describe('Connection Pool Initialization', () => {
        /**
         * Verifies that the pool is initialized with the correct connection string.
         */
        it('should initialize Pool with correct connection string', () => {
            expect(pool).toBeDefined();
            expect(pool.options.connectionString).toBe(config.databaseUrl);
        });

        /**
         * Ensures no initial connection test occurs in test environment.
         */
        it('should skip test connection in test environment', () => {
            const mockQuery = jest.spyOn(pool, 'query');
            expect(mockQuery).not.toHaveBeenCalled();
        });

        /**
         * Confirms that no "database connected" message is logged during tests.
         */
        it('should not log database connected message in test environment', () => {
            const consoleSpy = jest.spyOn(console, 'log');
            expect(consoleSpy).not.toHaveBeenCalledWith('Database connected successfully');
        });
    });

    describe('query() Functionality', () => {
        const mockQueryFn = pool.query as jest.Mock;

        beforeEach(() => {
            mockQueryFn.mockClear();
        });

        /**
         * Validates successful query execution and result return.
         */
        it('should execute a query and return results', async () => {
            const mockResult: QueryResult = {
                rows: [{ id: 1 }],
                rowCount: 1,
                command: '',
                oid: 0,
                fields: [],
            };

            mockQueryFn.mockResolvedValue(mockResult);

            const result = await query('SELECT * FROM users WHERE id = $1', [1]);

            expect(mockQueryFn).toHaveBeenCalledWith('SELECT * FROM users WHERE id = $1', [1]);
            expect(result).toEqual(mockResult);
        });

        /**
         * Ensures queries are logged in development environment with metadata.
         */
        it('should log query details in development environment', async () => {
            mockQueryFn.mockResolvedValue({
                rows: [],
                rowCount: 0,
                command: '',
                oid: 0,
                fields: [],
            });

            const consoleSpy = jest.spyOn(console, 'log');
            config.nodeEnv = 'development';

            await query('SELECT NOW()');

            expect(consoleSpy).toHaveBeenCalledWith(
                'Executed query:',
                expect.objectContaining({
                    text: 'SELECT NOW()',
                    params: undefined,
                    duration: expect.any(Number),
                    rows: expect.any(Number),
                })
            );

            config.nodeEnv = 'test'; // Reset for other tests
        });

        /**
         * Ensures no query logs appear in test environment.
         */
        it('should not log query details in test environment', async () => {
            mockQueryFn.mockResolvedValue({
                rows: [],
                rowCount: 0,
                command: '',
                oid: 0,
                fields: [],
            });

            const consoleSpy = jest.spyOn(console, 'log');
            config.nodeEnv = 'test';

            await query('SELECT NOW()');

            expect(consoleSpy).not.toHaveBeenCalledWith('Executed query:', expect.anything());
        });

        /**
         * Verifies rejection on query error propagation.
         */
        it('should reject on query error', async () => {
            mockQueryFn.mockRejectedValue(new Error('Connection failed'));

            await expect(query('SELECT NOW()')).rejects.toThrow('Connection failed');
        });

        /**
         * Confirms undefined parameters are passed correctly when omitted.
         */
        it('should pass parameters as undefined if not provided', async () => {
            const mockResult: QueryResult = {
                rows: [],
                rowCount: 0,
                command: '',
                oid: 0,
                fields: [],
            };

            mockQueryFn.mockResolvedValue(mockResult);

            await query('SELECT NOW()');

            expect(mockQueryFn).toHaveBeenCalledWith('SELECT NOW()', undefined);
        });
    });

    describe('getClient() Functionality', () => {
        const mockConnectFn = pool.connect as jest.Mock;

        /**
         * Validates that a PoolClient instance is returned upon successful connection.
         */
        it('should return a PoolClient instance', async () => {
            const mockClient = {
                release: jest.fn(),
                query: jest.fn(),
            } as unknown as PoolClient;

            mockConnectFn.mockResolvedValue(mockClient);

            const client = await getClient();

            expect(client).toBe(mockClient);
            expect(mockConnectFn).toHaveBeenCalled();
        });

        /**
         * Ensures errors from pool.connect() are propagated correctly.
         */
        it('should propagate errors from pool.connect()', async () => {
            mockConnectFn.mockRejectedValue(new Error('No connection'));

            await expect(getClient()).rejects.toThrow('No connection');
        });
    });
});