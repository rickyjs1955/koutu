// filepath: /backend/src/tests/integration/db.int.test.ts

import pg, { Pool } from 'pg';
import { setupTestDatabase, teardownTestDatabase } from '../../utils/testSetup';

describe('Integration tests for db.ts', () => {
    let pool: Pool;
    
    beforeAll(async () => {
        await setupTestDatabase();  // Setup koutu-postgres-test database
        
        // Create a new connection pool for testing
        pool = new Pool({
            host: 'localhost',
            port: 5433,
            user: 'postgres',
            password: 'password',
            database: 'koutu-postgres-test',
            connectionTimeoutMillis: 5000
        });
    });
    
    afterAll(async () => {
        // Clean up by dropping the tables and closing the connection pool
        await teardownTestDatabase();
        await pool.end();
    });
    
    describe('Database Connection', () => {
        it('should connect to the database', async () => {
            // Truncate table before each test
            await pool.query('TRUNCATE TABLE test_table');
            
            // Insert data for testing
            await pool.query(`INSERT INTO test_table (value) VALUES ('test')`);

            const res = await pool.query('SELECT * FROM test_table');
            expect(res.rows).toHaveLength(1);   // Expecting one row in the result set
        });
    });
    
    describe('Basic CRUD Operations', () => {
        it('should insert data into the database', async () => {
            // Truncate table before each test
            await pool.query('TRUNCATE TABLE test_table');
            
            const res = await pool.query(`INSERT INTO test_table (value) VALUES ('test') RETURNING *`);
            expect(res.rows).toHaveLength(1);   // Expecting one row in the result set after insertion
        });

        it('should delete data from the database', async () => {
            // Truncate table before each test
            await pool.query('TRUNCATE TABLE test_table');
            
            const res = await pool.query(`DELETE FROM test_table WHERE value='test' RETURNING *`);
            expect(res.rows).toHaveLength(0);   // Expecting no rows in the result set after deletion
        });

        it('should update data in the database', async () => {
            // Insert data for testing
            await pool.query(`INSERT INTO test_table (value) VALUES ('test')`);
            
            const res = await pool.query(`UPDATE test_table SET value='updated' WHERE value='test' RETURNING *`);
            expect(res.rows[0].value).toBe('updated');   // Expecting updated row in the result set after update
        });

        it('should select a specific value from the table', async () => {
            await pool.query('TRUNCATE TABLE test_table');
            await pool.query(`INSERT INTO test_table (value) VALUES ('test'), ('another')`);
            
            const res = await pool.query(`SELECT * FROM test_table WHERE value = 'test'`);
            expect(res.rows).toHaveLength(1);
            expect(res.rows[0].value).toBe('test');
        });
    });

    describe('Error Handling', () => {
        it('should handle errors when querying a non-existent table', async () => {
            try {
                const res = await pool.query('SELECT * FROM non_existent_table');
            } catch (error) {
                expect(error).toBeDefined();   // Expecting an error to be thrown
            }
        });

        // Tests previously known as 'should handle duplicate key violations'
        it('should explicitly catch and validate duplicate key violation errors', async () => {
            await pool.query('TRUNCATE TABLE test_table');
            await pool.query(`INSERT INTO test_table (value) VALUES ('duplicate')`);

            try {
                await pool.query(`INSERT INTO test_table (value) VALUES ('duplicate')`);
            } catch (error) {
                // First, assert the specific type at runtime for the test report
                expect(error).toBeInstanceOf(pg.DatabaseError);

                // Then, use a type guard for TypeScript to correctly narrow the type
                if (error instanceof pg.DatabaseError) {
                    // Now TypeScript knows 'error' is a pg.DatabaseError (which extends Error)
                    expect(error.message).toContain('duplicate key');
                    // You can also assert on specific properties like the SQLSTATE error code
                    // expect(error.code).toBe('23505'); // Example for PostgreSQL unique_violation code
                } else {
                    // This 'else' block catches anything that is NOT a pg.DatabaseError,
                    // which might include other types of Errors or entirely non-Error values.
                    fail('Expected a pg.DatabaseError for duplicate key violation, but received a different error type.');
                }
            }
        });
    });
    
    describe('Parameterized Queries', () => {
        it('should insert data using parameterized queries', async () => {
            await pool.query('TRUNCATE TABLE test_table');
            
            const res = await pool.query(`INSERT INTO test_table (value) VALUES ($1) RETURNING *`, ['param']);
            expect(res.rows[0].value).toBe('param');
        });
    });

    describe('Transactions', () => {
        it('should commit a transaction', async () => {
            await pool.query('TRUNCATE TABLE test_table');
            
            await pool.query(`BEGIN`);
            await pool.query(`INSERT INTO test_table (value) VALUES ('committed')`);
            await pool.query(`COMMIT`);
            
            const res = await pool.query(`SELECT * FROM test_table`);
            expect(res.rows).toHaveLength(1);
            expect(res.rows[0].value).toBe('committed');
        });

        it('should rollback a transaction', async () => {
            await pool.query('TRUNCATE TABLE test_table');
            
            await pool.query(`BEGIN`);
            await pool.query(`INSERT INTO test_table (value) VALUES ('rolled_back')`);
            await pool.query(`ROLLBACK`);
            
            const res = await pool.query(`SELECT * FROM test_table`);
            expect(res.rows).toHaveLength(0);
        });
    });

    describe('Edge Cases', () => {
        // Tests previously known as 'should handle duplicate key violations'
        it('should concisely assert duplicate key violation errors using Jest matchers', async () => {
            await pool.query('TRUNCATE TABLE test_table');
            await pool.query(`INSERT INTO test_table (value) VALUES ('duplicate')`);

            await expect(
                pool.query(`INSERT INTO test_table (value) VALUES ('duplicate')`)
            ).rejects.toThrow(
                expect.objectContaining({
                code: '23505',                    // unique_violation
                message: expect.stringContaining('duplicate key')
                })
            );
        });
    });

    describe('Pagination', () => {
        it('should retrieve data with LIMIT and OFFSET', async () => {
            await pool.query('TRUNCATE TABLE test_table');
            await pool.query(`INSERT INTO test_table (value) VALUES ('a'), ('b'), ('c'), ('d')`);
            
            const res = await pool.query(`SELECT * FROM test_table ORDER BY id LIMIT 2 OFFSET 1`);
            expect(res.rows).toHaveLength(2);
            expect(res.rows[0].value).toBe('b');
            expect(res.rows[1].value).toBe('c');
        });
    });

    describe('Schema Validation', () => {
        it('should verify table structure', async () => {
            const res = await pool.query(`SELECT * FROM information_schema.tables WHERE table_name = 'test_table'`);
            expect(res.rows).toHaveLength(1);
            expect(res.rows[0].table_name).toBe('test_table');
        });
    });
});